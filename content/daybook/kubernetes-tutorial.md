---
title: "Kubernetes Tutorial"
date: 2021-02-02T17:33:47-07:00
draft: false
---

Using this tutorial to learn Kubernetes concepts: [https://www.youtube.com/watch?v=X48VuDVv0do](https://www.youtube.com/watch?v=X48VuDVv0do).
`minikube` needs to run in a virtual environment, so we need to specify the vm-driver, hypberkit in our case.

`minikube start --vm-driver=hyperkit`

Once minikube is set up, it spins up a VM and then you can use `kubectl` to query it. Minikube is a node, running virtually in your own computer.

## Basic Commands Usage
creat a pod: `kubectl create ...`. 
We don't notmally work with pods directly. We work with deployments. So we use 
`kubectl create deploymend NAME --image=image`. The image needs to be specified since the pod needs to be created using some image

The deployment contains the blueprint for the pods. So it tells Kub what to create in the pod

`kubectl get replicaset` shows us the status of the pods replicas

- Deployment manages a
- replicaset manages a
- pod is an abstractin of the 
- container

we only worry about deployments. Kubernetes handles everything below thato

## Debugging

`kubectl logs NAME_OF_POD` (get the name from `kubectl get pods`)

`kubectl exec -it NAME_OF_POD -- bin/bash` will open a bash terminal in the pod (-it means interactive terminal)

## Configuration Files

In practice you use a configuration file

`kubectl apply -f config-file.yaml`

Kubernetes will attempt to make the deployment match the configuration file

### file

apiVersion:
kind: Deployment
metadata:
    name:
    labels:
spec:
    replicas:
    selector:
    template:
        this part is for the pods
        metadata:
        ...
        spec:

[status] automatically generated by kuberenetes
Kubernetes compares the status with the specs to make sure everything is where it needs to be

.yaml is very strict about indentations FYI

normally stored with the code.

labels must match `app` so that the service can know which pods it is managing

# Example

internal service 
configMap with DB url
secret with DB user and DB pwd

mongo-express will be available via an external service

mongo-express web app -> mongo express external service -> mongo express pod -> mongoDB internal service -> mongoDB pod
2 deployment/pod

when we set up the configuration file, we need some passwords and usernames, which we DON'T want to expose
So we store them in a `secret.yaml` file.

To store them, we should encrypt them as base64, and to do that `echo -n 'mystring' | base64`

Once you configure the secret, you actually have to apply it so it exists when you refer it

now we create an internal service so that other pods can talk to this pod

the `selector` of the service needs to match the `label` of the deployment

now we create the mongoexpress deployment. Needs to know which MongoDB (address internal service) and credentials
found in the docker image page

remember to create the configmap before you try to access it (creating it means running `kubectl apply -f the-configmap.yaml`)

Once we have the express pod running, we can then set up the external service, so that a browser can connect to the web app from external to the cluster

How to make an external service: needs to have type LoadBalancer (but internal service also has this type, but we need to write it here)
it assigns the service an external IP address
also specify a nodePort

to actually get the external IP for a minikube setup, we need to run `minikube service name-of-service`
